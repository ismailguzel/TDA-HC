

# This file was *autogenerated* from the file 4_Rips2Homological_Distance.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_5 = Integer(5); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10)# author:ismailguzel

import sys

dimmatrix = int(sys.argv[_sage_const_1 ])
homclass = int(sys.argv[_sage_const_2 ])
epsilonstart = int(sys.argv[_sage_const_3 ])
epsilonend = float(sys.argv[_sage_const_4 ])
epsilonstep = float(sys.argv[_sage_const_5 ])

import json
with open("Outputs/simplex_with_epsilon.txt", "r") as file:
    res=json.loads(file.read())

def myfunc(eps,res):
    return [e[_sage_const_0 ] for e in res if(e[_sage_const_1 ]<=eps)]


def mymatrix(dimmatrix, n, epsilon1, epsilon2):    
    X1=SimplicialComplex(myfunc(epsilon1,res))   
    X2=SimplicialComplex(myfunc(epsilon2,res))
    X1.set_immutable()
    X2.set_immutable()
    CC1 = X1.n_chains(_sage_const_2 , QQ).chain_complex()
    CC2 = X2.n_chains(_sage_const_2 , QQ).chain_complex()
    HX1=X1.homology_with_basis(QQ)
    HX1_basis = HX1.basis()
    mylast = []
    for i in range(CC1.betti(n)):
        for j in range(i+_sage_const_1 ,CC1.betti(n)):
            diff = HX1_basis[n,i].to_cycle()-HX1_basis[n,j].to_cycle()
            if diff==_sage_const_0 :
                break
            mylist = list(diff.to_vector())
            mydim = CC1.differential(_sage_const_1 ).dimensions()
            mydim1 =CC2.differential(_sage_const_1 ).dimensions()
            for i in range(mydim1[_sage_const_0 ]-mydim[_sage_const_0 ]):
                mylist.append(_sage_const_0 )
            mytuple= tuple(mylist)
            myoriginal = CC2.differential(_sage_const_1 )
            mylist = list(CC2.differential(_sage_const_1 ).transpose())
            mylist.append(mytuple)
            mylist = [list(tp) for tp in mylist]
            if rank(myoriginal)==rank(matrix(mylist)):
                  mylast.append([HX1_basis[_sage_const_0 ,i].to_cycle(),HX1_basis[_sage_const_0 ,j].to_cycle()]) 
    import re
    import numpy as np
    rows = [ int(re.findall(r"\d+", str(index[_sage_const_0 ]) )[_sage_const_0 ]) for index in mylast]
    columns = [ int(re.findall(r"\d+", str(index[_sage_const_1 ]) )[_sage_const_0 ]) for index in mylast]
    A = _sage_const_10 *np.ones((dimmatrix,dimmatrix))
    for i in range(len(rows)):
        A[rows[i]][columns[i]] = epsilon2
        A[columns[i]][rows[i]] = epsilon2
    return A


def distancematrix(dimmatrix, n, eps1, eps2, step):
    import numpy as np
    epsilon1 = np.arange(eps1, eps2, step)
    epsilon2 = np.arange(eps1+step , eps2+step, step)
    A = []
    for i in range(len(epsilon1)):
        A.append(mymatrix(dimmatrix, n, epsilon1[i], epsilon2[i]))
    B = A[_sage_const_0 ]
    for i in range(len(epsilon1)-_sage_const_1 ):
        B = np.where(B <= A[i+_sage_const_1 ], B, A[i+_sage_const_1 ])
    return B

C = distancematrix(dimmatrix, homclass, epsilonstart, epsilonend, epsilonstep)

import pandas as pd
dataframe = pd.DataFrame(C)
dataframe.to_csv("Outputs/homological_distance.txt")

